<?php

declare(strict_types=1);

/*
 * PagarmeApiSDKLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace PagarmeApiSDKLib\Controllers;

use PagarmeApiSDKLib\Exceptions\ApiException;
use PagarmeApiSDKLib\ApiHelper;
use PagarmeApiSDKLib\ConfigurationInterface;
use PagarmeApiSDKLib\Utils\DateTimeHelper;
use PagarmeApiSDKLib\Http\HttpRequest;
use PagarmeApiSDKLib\Http\HttpResponse;
use PagarmeApiSDKLib\Http\HttpMethod;
use PagarmeApiSDKLib\Http\HttpContext;
use PagarmeApiSDKLib\Http\HttpCallBack;
use Unirest\Request;

class SubscriptionsController extends BaseController
{
    public function __construct(ConfigurationInterface $config, array $authManagers, ?HttpCallBack $httpCallBack)
    {
        parent::__construct($config, $authManagers, $httpCallBack);
    }

    /**
     * @param string $subscriptionId
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetPeriodResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function renewSubscription(
        string $subscriptionId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetPeriodResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/cycles';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetPeriodResponse');
    }

    /**
     * Deletes a discount
     *
     * @param string $subscriptionId Subscription id
     * @param string $discountId Discount Id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetDiscountResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function deleteDiscount(
        string $subscriptionId,
        string $discountId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetDiscountResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/discounts/{discount_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'discount_id'     => $discountId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::delete($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetDiscountResponse');
    }

    /**
     * Gets all subscriptions
     *
     * @param int|null $page Page number
     * @param int|null $size Page size
     * @param string|null $code Filter for subscription's code
     * @param string|null $billingType Filter for subscription's billing type
     * @param string|null $customerId Filter for subscription's customer id
     * @param string|null $planId Filter for subscription's plan id
     * @param string|null $cardId Filter for subscription's card id
     * @param string|null $status Filter for subscription's status
     * @param \DateTime|null $nextBillingSince Filter for subscription's next billing date start
     *        range
     * @param \DateTime|null $nextBillingUntil Filter for subscription's next billing date end range
     * @param \DateTime|null $createdSince Filter for subscription's creation date start range
     * @param \DateTime|null $createdUntil Filter for subscriptions creation date end range
     *
     * @return \PagarmeApiSDKLib\Models\ListSubscriptionsResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscriptions(
        ?int $page = null,
        ?int $size = null,
        ?string $code = null,
        ?string $billingType = null,
        ?string $customerId = null,
        ?string $planId = null,
        ?string $cardId = null,
        ?string $status = null,
        ?\DateTime $nextBillingSince = null,
        ?\DateTime $nextBillingUntil = null,
        ?\DateTime $createdSince = null,
        ?\DateTime $createdUntil = null
    ): \PagarmeApiSDKLib\Models\ListSubscriptionsResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions';

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'               => $page,
            'size'               => $size,
            'code'               => $code,
            'billing_type'       => $billingType,
            'customer_id'        => $customerId,
            'plan_id'            => $planId,
            'card_id'            => $cardId,
            'status'             => $status,
            'next_billing_since' => DateTimeHelper::toRfc3339DateTime($nextBillingSince),
            'next_billing_until' => DateTimeHelper::toRfc3339DateTime($nextBillingUntil),
            'created_since'      => DateTimeHelper::toRfc3339DateTime($createdSince),
            'created_until'      => DateTimeHelper::toRfc3339DateTime($createdUntil),
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'       => self::$userAgent,
            'Accept'           => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListSubscriptionsResponse');
    }

    /**
     * @param string $subscriptionId The subscription id
     * @param string $discountId
     *
     * @return \PagarmeApiSDKLib\Models\GetDiscountResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getDiscountById(
        string $subscriptionId,
        string $discountId
    ): \PagarmeApiSDKLib\Models\GetDiscountResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/discounts/{discountId}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'discountId'      => $discountId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetDiscountResponse');
    }

    /**
     * Creates a new subscription
     *
     * @param \PagarmeApiSDKLib\Models\CreateSubscriptionRequest $body Request for creating a
     *        subscription
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createSubscription(
        \PagarmeApiSDKLib\Models\CreateSubscriptionRequest $body,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions';

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($body);

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId The subscription Id
     * @param string $incrementId The increment Id
     *
     * @return \PagarmeApiSDKLib\Models\GetIncrementResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getIncrementById(
        string $subscriptionId,
        string $incrementId
    ): \PagarmeApiSDKLib\Models\GetIncrementResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/increments/{increment_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'increment_id'    => $incrementId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetIncrementResponse');
    }

    /**
     * Updates the metadata from a subscription
     *
     * @param string $subscriptionId The subscription id
     * @param \PagarmeApiSDKLib\Models\UpdateMetadataRequest $request Request for updating the
     *        subscrption metadata
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionMetadata(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateMetadataRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/Subscriptions/{subscription_id}/metadata';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Deletes a increment
     *
     * @param string $subscriptionId Subscription id
     * @param string $incrementId Increment id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetIncrementResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function deleteIncrement(
        string $subscriptionId,
        string $incrementId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetIncrementResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/increments/{increment_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'increment_id'    => $incrementId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::delete($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetIncrementResponse');
    }

    /**
     * Gets a subscription
     *
     * @param string $subscriptionId Subscription id
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscription(string $subscriptionId): \PagarmeApiSDKLib\Models\GetSubscriptionResponse
    {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId
     * @param \PagarmeApiSDKLib\Models\UpdateCurrentCycleEndDateRequest $request Request for
     *        updating the end date of the current signature cycle
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateLatestPeriodEndAt(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateCurrentCycleEndDateRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/periods/latest/end-at';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId Subscription Id
     * @param \PagarmeApiSDKLib\Models\UpdateCurrentCycleStatusRequest $request Request for updating
     *        the end date of the subscription current status
     * @param string|null $idempotencyKey
     *
     * @return void Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateCurrentCycleStatus(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateCurrentCycleStatusRequest $request,
        ?string $idempotencyKey = null
    ): void {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/cycle-status';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
    }

    /**
     * Get Subscription Items
     *
     * @param string $subscriptionId The subscription id
     * @param int|null $page Page number
     * @param int|null $size Page size
     * @param string|null $name The item name
     * @param string|null $code Identification code in the client system
     * @param string|null $status The item statis
     * @param string|null $description The item description
     * @param string|null $createdSince Filter for item's creation date start range
     * @param string|null $createdUntil Filter for item's creation date end range
     *
     * @return \PagarmeApiSDKLib\Models\ListSubscriptionItemsResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscriptionItems(
        string $subscriptionId,
        ?int $page = null,
        ?int $size = null,
        ?string $name = null,
        ?string $code = null,
        ?string $status = null,
        ?string $description = null,
        ?string $createdSince = null,
        ?string $createdUntil = null
    ): \PagarmeApiSDKLib\Models\ListSubscriptionItemsResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'            => $page,
            'size'            => $size,
            'name'            => $name,
            'code'            => $code,
            'status'          => $status,
            'description'     => $description,
            'created_since'   => $createdSince,
            'created_until'   => $createdUntil,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListSubscriptionItemsResponse');
    }

    /**
     * Get Subscription Item
     *
     * @param string $subscriptionId Subscription Id
     * @param string $itemId Item id
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscriptionItem(
        string $subscriptionId,
        string $itemId
    ): \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionItemResponse');
    }

    /**
     * @param string $subscriptionId
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionAffiliationIdRequest $request Request for
     *        updating a subscription affiliation id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionAffiliationId(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionAffiliationIdRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/gateway-affiliation-id';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId The subscription id
     * @param int $page Page number
     * @param int $size Page size
     *
     * @return \PagarmeApiSDKLib\Models\ListDiscountsResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getDiscounts(
        string $subscriptionId,
        int $page,
        int $size
    ): \PagarmeApiSDKLib\Models\ListDiscountsResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/discounts/';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'            => $page,
            'size'            => $size,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListDiscountsResponse');
    }

    /**
     * Updates a subscription item
     *
     * @param string $subscriptionId Subscription Id
     * @param string $itemId Item id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionItemRequest $body Request for updating a
     *        subscription item
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionItem(
        string $subscriptionId,
        string $itemId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionItemRequest $body,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($body);

        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::put($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionItemResponse');
    }

    /**
     * Creates a new Subscription item
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\CreateSubscriptionItemRequest $request Request for creating a
     *        subscription item
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createSubscriptionItem(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\CreateSubscriptionItemRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionItemResponse');
    }

    /**
     * Lists all usages from a subscription item
     *
     * @param string $subscriptionId The subscription id
     * @param string $itemId The subscription item id
     * @param int|null $page Page number
     * @param int|null $size Page size
     * @param string|null $code Identification code in the client system
     * @param string|null $group Identification group in the client system
     * @param \DateTime|null $usedSince
     * @param \DateTime|null $usedUntil
     *
     * @return \PagarmeApiSDKLib\Models\ListUsagesResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getUsages(
        string $subscriptionId,
        string $itemId,
        ?int $page = null,
        ?int $size = null,
        ?string $code = null,
        ?string $group = null,
        ?\DateTime $usedSince = null,
        ?\DateTime $usedUntil = null
    ): \PagarmeApiSDKLib\Models\ListUsagesResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}/usages';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
        ]);

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'            => $page,
            'size'            => $size,
            'code'            => $code,
            'group'           => $group,
            'used_since'      => DateTimeHelper::toRfc3339DateTime($usedSince),
            'used_until'      => DateTimeHelper::toRfc3339DateTime($usedUntil),
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListUsagesResponse');
    }

    /**
     * Atualização do valor mínimo da assinatura
     *
     * @param string $subscriptionId Subscription Id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionMinimumPriceRequest $request Request da
     *        requisição com o valor mínimo que será configurado
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionMiniumPrice(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionMinimumPriceRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/minimum_price';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId The subscription id
     * @param string $cycleId
     *
     * @return \PagarmeApiSDKLib\Models\GetPeriodResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscriptionCycleById(
        string $subscriptionId,
        string $cycleId
    ): \PagarmeApiSDKLib\Models\GetPeriodResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/cycles/{cycleId}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'cycleId'         => $cycleId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetPeriodResponse');
    }

    /**
     * Create Usage
     *
     * @param string $subscriptionId Subscription id
     * @param string $itemId Item id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetUsageResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createAnUsage(
        string $subscriptionId,
        string $itemId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetUsageResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}/usages';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetUsageResponse');
    }

    /**
     * Cancels a subscription
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\CreateCancelSubscriptionRequest|null $request Request for
     *        cancelling a subscription
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function cancelSubscription(
        string $subscriptionId,
        ?\PagarmeApiSDKLib\Models\CreateCancelSubscriptionRequest $request = null,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::delete($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Deletes a subscription item
     *
     * @param string $subscriptionId Subscription id
     * @param string $subscriptionItemId Subscription item id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function deleteSubscriptionItem(
        string $subscriptionId,
        string $subscriptionItemId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionItemResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{subscription_item_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id'      => $subscriptionId,
            'subscription_item_id' => $subscriptionItemId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'         => self::$userAgent,
            'Accept'             => 'application/json',
            'idempotency-key'      => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::delete($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionItemResponse');
    }

    /**
     * @param string $subscriptionId The subscription id
     * @param int|null $page Page number
     * @param int|null $size Page size
     *
     * @return \PagarmeApiSDKLib\Models\ListIncrementsResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getIncrements(
        string $subscriptionId,
        ?int $page = null,
        ?int $size = null
    ): \PagarmeApiSDKLib\Models\ListIncrementsResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/increments/';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'            => $page,
            'size'            => $size,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListIncrementsResponse');
    }

    /**
     * Updates the boleto due days from a subscription
     *
     * @param string $subscriptionId Subscription Id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionDueDaysRequest $request
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionDueDays(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionDueDaysRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/boleto-due-days';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Updates the credit card from a subscription
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionCardRequest $request Request for updating a
     *        card
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionCard(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionCardRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/card';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Deletes a usage
     *
     * @param string $subscriptionId The subscription id
     * @param string $itemId The subscription item id
     * @param string $usageId The usage id
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetUsageResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function deleteUsage(
        string $subscriptionId,
        string $itemId,
        string $usageId,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetUsageResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}/usages/{usage_id}';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
            'usage_id'        => $usageId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::delete($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetUsageResponse');
    }

    /**
     * Creates a discount
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\CreateDiscountRequest $request Request for creating a
     *        discount
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetDiscountResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createDiscount(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\CreateDiscountRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetDiscountResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/discounts';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetDiscountResponse');
    }

    /**
     * Updates the payment method from a subscription
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionPaymentMethodRequest $request Request for
     *        updating the paymentmethod from a subscription
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionPaymentMethod(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionPaymentMethodRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/payment-method';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Creates a increment
     *
     * @param string $subscriptionId Subscription id
     * @param \PagarmeApiSDKLib\Models\CreateIncrementRequest $request Request for creating a
     *        increment
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetIncrementResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createIncrement(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\CreateIncrementRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetIncrementResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/increments';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetIncrementResponse');
    }

    /**
     * Creates a usage
     *
     * @param string $subscriptionId Subscription Id
     * @param string $itemId Item id
     * @param \PagarmeApiSDKLib\Models\CreateUsageRequest $body Request for creating a usage
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetUsageResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function createUsage(
        string $subscriptionId,
        string $itemId,
        \PagarmeApiSDKLib\Models\CreateUsageRequest $body,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetUsageResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/items/{item_id}/usages';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'item_id'         => $itemId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($body);

        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::post($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetUsageResponse');
    }

    /**
     * @param string $subscriptionId Subscription Id
     * @param string $page Page number
     * @param string $size Page size
     *
     * @return \PagarmeApiSDKLib\Models\ListCyclesResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getSubscriptionCycles(
        string $subscriptionId,
        string $page,
        string $size
    ): \PagarmeApiSDKLib\Models\ListCyclesResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/cycles';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //process optional query parameters
        ApiHelper::appendUrlWithQueryParameters($_queryBuilder, [
            'page'            => $page,
            'size'            => $size,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\ListCyclesResponse');
    }

    /**
     * Updates the billing date from a subscription
     *
     * @param string $subscriptionId The subscription id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionBillingDateRequest $request Request for
     *        updating the subscription billing date
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionBillingDate(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionBillingDateRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/billing-date';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * Updates the start at date from a subscription
     *
     * @param string $subscriptionId The subscription id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionStartAtRequest $request Request for
     *        updating the subscription start date
     * @param string|null $idempotencyKey
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSubscriptionStartAt(
        string $subscriptionId,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionStartAtRequest $request,
        ?string $idempotencyKey = null
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/start-at';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json',
            'idempotency-key' => $idempotencyKey
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }

    /**
     * @param string $subscriptionId The subscription Id
     * @param string $periodId The period Id
     *
     * @return \PagarmeApiSDKLib\Models\GetUsageReportResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getUsageReport(
        string $subscriptionId,
        string $periodId
    ): \PagarmeApiSDKLib\Models\GetUsageReportResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{subscription_id}/periods/{period_id}/usages/report';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'subscription_id' => $subscriptionId,
            'period_id'       => $periodId,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json'
        ];

        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::get($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders());
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetUsageReportResponse');
    }

    /**
     * @param string $id Subscription's id
     * @param \PagarmeApiSDKLib\Models\UpdateSubscriptionSplitRequest $request
     *
     * @return \PagarmeApiSDKLib\Models\GetSubscriptionResponse Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function updateSplitSubscription(
        string $id,
        \PagarmeApiSDKLib\Models\UpdateSubscriptionSplitRequest $request
    ): \PagarmeApiSDKLib\Models\GetSubscriptionResponse {
        //prepare query string for API call
        $_queryBuilder = '/subscriptions/{id}/split';

        //process optional query parameters
        $_queryBuilder = ApiHelper::appendUrlWithTemplateParameters($_queryBuilder, [
            'id'      => $id,
        ]);

        //validate and preprocess url
        $_queryUrl = ApiHelper::cleanUrl($this->config->getBaseUri() . $_queryBuilder);

        //prepare headers
        $_headers = [
            'user-agent'    => self::$userAgent,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json'
        ];

        //json encode body
        $_bodyJson = ApiHelper::serialize($request);

        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);

        // Apply authorization to request
        $this->getAuthManager('global')->apply($_httpRequest);

        //call on-before Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        // and invoke the API call request to fetch the response
        try {
            $response = Request::patch($_httpRequest->getQueryUrl(), $_httpRequest->getHeaders(), $_bodyJson);
        } catch (\Unirest\Exception $ex) {
            throw new ApiException($ex->getMessage(), $_httpRequest);
        }


        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpRequest);
        $mapper = $this->getJsonMapper();
        return $mapper->mapClass($response->body, 'PagarmeApiSDKLib\\Models\\GetSubscriptionResponse');
    }
}
