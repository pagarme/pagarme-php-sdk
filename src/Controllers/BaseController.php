<?php

declare(strict_types=1);

/*
 * PagarmeApiSDKLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace PagarmeApiSDKLib\Controllers;

use PagarmeApiSDKLib\Http\HttpCallBack;
use PagarmeApiSDKLib\Http\HttpResponse;
use PagarmeApiSDKLib\Http\HttpRequest;
use PagarmeApiSDKLib\Exceptions\ApiException;
use PagarmeApiSDKLib\ConfigurationInterface;
use PagarmeApiSDKLib\AuthManagerInterface;
use apimatic\jsonmapper\JsonMapper;
use Unirest\Request;

/**
 * Base controller
 */
class BaseController
{
    /**
     * Configuration instance
     *
     * @var ConfigurationInterface
     */
    protected $config;

    /**
     * List of auth managers for this controller.
     *
     * @var array
     */
    private $authManagers = [];

    /**
     * HttpCallBack instance associated with this controller
     *
     * @var HttpCallBack|null
     */
    private $httpCallBack;

    /**
     * User-Agent header value to be sent with API calls.
     *
     * @var string
     */
    protected static $userAgent = 'PagarmeCoreApi - PHP 6.1.0-alpha.0';

    /**
     * Constructor that sets the timeout of requests
     */
    protected function __construct(ConfigurationInterface $config, array $authManagers, ?HttpCallBack $httpCallBack)
    {
        $this->config = $config;
        $this->authManagers = $authManagers;
        $this->httpCallBack = $httpCallBack;

        Request::timeout($config->getTimeout());
        Request::enableRetries($config->shouldEnableRetries());
        Request::maxNumberOfRetries($config->getNumberOfRetries());
        Request::retryInterval($config->getRetryInterval());
        Request::backoffFactor($config->getBackOffFactor());
        Request::maximumRetryWaitTime($config->getMaximumRetryWaitTime());
        Request::retryOnTimeout($config->shouldRetryOnTimeout());
        Request::httpMethodsToRetry($config->getHttpMethodsToRetry());
        Request::httpStatusCodesToRetry($config->getHttpStatusCodesToRetry());
    }

    /**
     * Get auth manager for the provided namespace key.
     *
     * @param  string   $key         Namespace key
     * @return AuthManagerInterface  The AuthManager set for this key.
     */
    protected function getAuthManager(string $key): AuthManagerInterface
    {
        return $this->authManagers[$key];
    }

    /**
     * Get HttpCallBack for this controller
     *
     * @return HttpCallBack|null The HttpCallBack object set for this controller
     */
    public function getHttpCallBack(): ?HttpCallBack
    {
        return $this->httpCallBack;
    }

    /**
     * Get a new JsonMapper instance for mapping objects
     *
     * @return \apimatic\jsonmapper\JsonMapper JsonMapper instance
     */
    protected function getJsonMapper(): JsonMapper
    {
        $mapper = new JsonMapper();
        $mapper->arChildClasses['PagarmeApiSDKLib\\Models\\GetTransactionResponse'] = [
            'PagarmeApiSDKLib\\Models\\GetBankTransferTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetSafetyPayTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetVoucherTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetBoletoTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetDebitCardTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetPrivateLabelTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetCashTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetCreditCardTransactionResponse',
            'PagarmeApiSDKLib\\Models\\GetPixTransactionResponse'
        ];
        return $mapper;
    }

    /**
     * Validate response or throw exception based on the status code
     */
    protected function validateResponse(HttpResponse $response, HttpRequest $request): void
    {
        if ($response->getStatusCode() == 400) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'Invalid request',
                $request,
                $response
            );
        }
        if ($response->getStatusCode() == 401) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'Invalid API key',
                $request,
                $response
            );
        }
        if ($response->getStatusCode() == 404) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'An informed resource was not found',
                $request,
                $response
            );
        }
        if ($response->getStatusCode() == 412) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'Business validation error',
                $request,
                $response
            );
        }
        if ($response->getStatusCode() == 422) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'Contract validation error',
                $request,
                $response
            );
        }
        if ($response->getStatusCode() == 500) {
            throw $this->createExceptionFromJson(
                '\\PagarmeApiSDKLib\\Exceptions\\ErrorException',
                'Internal server error',
                $request,
                $response
            );
        }
        if (($response->getStatusCode() < 200) || ($response->getStatusCode() > 208)) { //[200,208] = HTTP OK
            throw new ApiException('HTTP Response Not OK', $request, $response);
        }
    }

    /**
     * Create and get ApiException-derived exception instance
     */
    protected function createExceptionFromJson(
        string $type,
        string $reason,
        HttpRequest $request,
        HttpResponse $response
    ) {
        $body = json_decode($response->getRawBody());

        if ($body === null) {
            return new ApiException($reason, $request, $response);
        } else {
            $body->reason = $reason;
            $body->request = $request;
            $body->response = $response;
        }

        return $this->getJsonMapper()->mapClass($body, $type);
    }
}
